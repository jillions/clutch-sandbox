/* THIS FILE WAS AUTOGENERATED BY CLUTCH. DO NOT EDIT. */
import React from 'react';
import qs from 'qs';
import isEqual from 'lodash.isequal';

function getReactElementTextContent(elem: React.ReactElement | string): string {
  if (!elem) {
    return '';
  }

  if (typeof elem === 'string') {
    return elem;
  }

  const children = elem?.props?.children;

  if (children && Array.isArray(children)) {
    return children.map(getReactElementTextContent).join('');
  }

  return getReactElementTextContent(children);
}

export function serialize(obj: any): any {
  if (obj && React.isValidElement(obj)) {
    return getReactElementTextContent(obj);
  }

  if (typeof obj === 'function') {
    let res = obj;

    try {
      // next may make this fail if it's a react function
      res = obj.toString();
    } catch (err) {
      // ignore
    }

    return res;
  }

  if (obj === undefined || obj === null || typeof obj !== 'object') {
    return obj;
  }

  if (obj && Array.isArray(obj)) {
    return obj.map(serialize);
  }

  const copiedObject = {};

  Object.keys(obj).forEach((key) => {
    copiedObject[key] = serialize(obj[key]);
  });

  return copiedObject;
}

export function parseSearchParams(searchParams: any): any {
  const parsedParams = qs.parse(searchParams, { ignoreQueryPrefix: true });

  return parsedParams;
}

export function tryCatchFn(fn: Function, ...args: any[]): any {
  try {
    return fn(...args);
  } catch (err) {
  }
}

export function omit<T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> {
  const result = {} as Omit<T, K>;
  for (const key in obj) {
      if (!keys.includes(key as K)) {
          result[key] = obj[key];
      }
  }
  return result;
}

export function useDeepEqual(selector) {
  const prev = React.useRef();

  return (state) => {
    const next = selector(state);

    return isEqual(prev.current, next) ? prev.current : (prev.current = next);
  };
}
